# 42-CPP-Piscines
<details>
  <summary> CPP_00-ex00 </summary>
Можно юзать системную штуку (char)toupper

```
#include <iostream>

int main()
{
	std::cout << "Hello World!" << std::endl;
	return 0;
}
```
Чтобы читать или писать в стандартный поток ввода/вывода необходимо включить <iostream>
Любая переменная или объект, существующий в стандартной библиотеке C++, включается в стандартное пространство имен std.
Чтобы использовать стандартный объект вывода, вам нужно написать std::cout, чтобы присоединить [пространство имен](https://docs.microsoft.com/ru-ru/cpp/cpp/namespaces-cpp?view=msvc-170)
Пространство имен означает принадлежность определенному объекту или функции. Когда объект объявлен в a() и b(), это означает, что он может использоваться только с другим префиксом.\
abc a::abc b::abc
```
int doSomething(int x, int y)
{
	return x + y;
}
```
```
int doSomething(int x, int y)
{
	return x - y;
}
```
```
#include <iostream>
int main()
{
	std::cout << doSomething(4, 3);
	return 0;
}
```
Если эти два параметра включены в одну и ту же программу, что и в примере, возникает конфликт имен, поскольку функция с тем же именем и параметром находится в той же области.
```
namespace Foo
{
	int doSomething(int x, int y)
	{
		return x + y;
	}
}
```
```
namespace Goo
{
	int doSomething(int x, int y)
	{
		return x - y;
	}
}
```
```
#include <iostream>

int main()
{
	std::cout << Foo::doSomething(4, 3); << '\n'
	std::cout << Goo::doSomething(4, 3); << endl
	return 0;
}
```
Если над проектом работают два разработчика и они оба решили назвать свою функцию doSomething, то при сборке будет больно. Поэтому можно использовать пространство имён. Для этого используем namespace Foo и namespace Goo. Таким образом обе функции doSomething не будут ничего знать друг о друге и всё скомпилируется успешно.
Оператор разрешения области действия (::) необходим для поиска идентификаторов в каждом пространстве имен.
Чтобы использовать этот оператор, добавьте к имени идентификатора префикс пространства имен, которое будет использоваться.
</details>
	
<details>
  <summary> CPP_01-ex00 </summary>
Два способа объявить зомби

Zombie stackZombie = Zombie("stackZombie");

Zombie *heapZombie = newZombie("heapZombie");

Области хранения данных: 
1. [text area] \
где хранится код программы, которую мы запускаем
2. [data] \
область где хранится global and static variables
3. [stack] \
Здесь сохраняются локальные переменные и параметры, связанные с вызовом функции.

Область стека выделяется вместе с вызовом функции и уничтожается по завершении вызова функции. Информация о вызове функции, хранящаяся в стеке, называется [кадром стека](https://en.wikipedia.org/wiki/Call_stack).

Область стека хранит данные методом push и извлекает данные методом pop. Поскольку этот стек работает в соответствии с методом «последним пришел — первым вышел», последние сохраненные данные извлекаются первыми.

Область стека распределяется от старшего адреса к младшему в памяти. Размер определяется во время выполнения.

4. [heap] \
Это область памяти, которой пользователь может напрямую управлять и должен это делать. Пространство памяти динамически выделяется и освобождается пользователем.

Область кучи распределяется от младшего адреса к старшему адресу в памяти.

Размер определяется во время компиляции. Утечка памяти происходит, если выделение не освобождается в конце использования.
	
## Преимущества и недостатки стека и кучи
### stack
+очень быстрый доступ

+Нет необходимости явно освобождать переменные
	
+Пространство эффективно управляется процессором, а память не фрагментируется.
	
-Размер стека ограничен ОС
	
-Невозможно изменить размер переменной
	
### heap
	
+Доступ к переменным возможен глобально
	
+Нет ограничений на размер памяти
	
-относительно медленный доступ
	
-Неспособность обеспечить эффективное использование пространства может привести к фрагментации блоков памяти и их освобождению с течением времени после их выделения.
	
-Вы должны управлять памятью самостоятельно (выделять и освобождать переменные напрямую)
### Соответственно что делаем
В случае функции randomChump можно выделить область стека, потому что экземпляр выполняет все свои роли внутри функции.
	
Функция newZombie должна иметь возможность использовать экземпляр зомби, созданный в другом месте, поэтому целесообразно создать экземпляр в области кучи.
### Отличие heap от free store
Чисто концептуальное. Одна баночка для хранения печенья, другая для хранения жуков. 
	
new and delete - free store

malloc and free - heap

new выделяет память и вызывает конструктор,
delete фришит и вызывает деструктор
</details>

<details>
  <summary> CPP_01-ex01 </summary>

## Делаем вот что

Создаём функцию, которая создает массив зомби с помощью созданного ранее класса и возвращает адрес на первого зомби, т.е. создаём [массив объектов](https://www.geeksforgeeks.org/array-of-objects-in-c-with-examples/), содержащий объекты(зомби). Массив объектов должен быть размещен в области кучи. 

```Zombie* zombieHorde( int N, std::string name );```
	
### Массив объектов VS массив указателей на объекты

Точно так же, как массивы могут содержать символы или целые числа, объекты также могут храниться в массивах.

Есть два способа поместить объект в массив. Один — поместить сам объект в массив, а другой — сохранить адрес объекта. Массив, созданный первым методом, называется массивом объектов, а второй случай называется массивом указателей на объекты.

Массив объектов создается одновременно с объявлением, но массив указателей объекта должен динамически выделяться один за другим после объявления, а возвращенное значение адреса объекта должно быть присвоено массиву. Парампампам

Объекты такой длины, как длина массива, могут быть созданы одновременно только путем объявления массива объектов, поэтому исходя из сабжа будем делать так
</details>

<details>
  <summary> CPP_01-ex02 </summary>
Когда программа запускается, она говорит «HI THIS IS BRAIN».
	
Нам нужно создать указатель, содержащий адрес этой строки (stringPTR).
	
Ещё должны создать ссылку, содержащую ссылку на ту же строку(stringREF).
	
Вывести адрес строки и строку, используя stringPTR и stringREF.
### Разница между ссылкой и указателем

1. Ссылочный тип (&) должен быть инициализирован как допустимый объект во время объявления. Так как нулевой ссылки не существует

2. Указатель (*) может указывать на адрес другой переменной в любое время.
```
	std::string	str = "HI THIS IS BRAIN";
	std::string	*stringPTR = &str;
	std::string	&stringREF = str;
```
& не адрес, а ссылка
	
std::string& stringREF = s; //reference// & - ссылка на строку //  & = string; 
	
Ссылка: пробел, содержащий значение объекта
	
Ссылки могут использоваться для доступа к фактическим значениям

```std::string *stringPTR = &s; ```
	
```pointer// * - указатель на строку REF ```
	
```* = &s -> значение адреса переменной```
	
Указатель: переменная, указывающая на адрес объекта
	
stringPTR = &s; 
	
```* = &```
	
```
int x = 0;
	int y = 0;
	std::cout << "+---------------------------------+" << std::endl;
	std::cout << "int y = 0: " << y << std::endl;
	std::cout << "int x = 0: " << x << std::endl;
	int *p = &x;
	int *q = &y;
	std::cout << "+---------------------------------+" << std::endl;
	std::cout << "int *q = &y: " << y << std::endl;
	std::cout << "int *p = &x: " << x << std::endl;
	std::cout << "now adress y: " << *p << std::endl;
	std::cout << "now adress x: " << *q << std::endl;
	std::cout << "+---------------------------------+" << std::endl;
	int **pp = &p;
	std::cout << "**pp = &p: " << y << std::endl;
	std::cout << "**pp = &p: " << x << std::endl;
	std::cout << "now adress: " << **pp << std::endl;
	std::cout << "+---------------------------------+" << std::endl;
	**pp = 2;
	std::cout << "**pp = 2: " << y << std::endl;
	std::cout << "**pp = 2: " << x << std::endl;
	std::cout << "now adress: " << **pp << std::endl;
	std::cout << "+---------------------------------+" << std::endl;
	pp = &q; // *pp is now q
	std::cout << "pp = &q: " << y << std::endl;
	std::cout << "pp = &q: " << x << std::endl;
	std::cout << "now adress: " << pp << std::endl;
	**pp = 4;
	std::cout << "now adress: " << pp << std::endl;

	//assert(y == 4);
	//assert(x == 2);
	std::cout << "y: " << y << std::endl;
	std::cout << "x: " << x << std::endl;
```
<img width="332" alt="Снимок экрана 2022-03-28 в 16 22 23" src="https://user-images.githubusercontent.com/84707645/160407107-d581cbdf-d924-44eb-accb-0faf6c2f80c6.png">

</details>
