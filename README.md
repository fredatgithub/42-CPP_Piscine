# 42-CPP-Piscines
<details>
  <summary> CPP_00-ex00 </summary>
Можно юзать системную штуку (char)toupper

```
#include <iostream>

int main()
{
	std::cout << "Hello World!" << std::endl;
	return 0;
}
```
Чтобы читать или писать в стандартный поток ввода/вывода необходимо включить <iostream>
Любая переменная или объект, существующий в стандартной библиотеке C++, включается в стандартное пространство имен std.
Чтобы использовать стандартный объект вывода, вам нужно написать std::cout, чтобы присоединить [пространство имен](https://docs.microsoft.com/ru-ru/cpp/cpp/namespaces-cpp?view=msvc-170)
Пространство имен означает принадлежность определенному объекту или функции. Когда объект объявлен в a() и b(), это означает, что он может использоваться только с другим префиксом.\
abc a::abc b::abc
```
int doSomething(int x, int y)
{
	return x + y;
}
```
```
int doSomething(int x, int y)
{
	return x - y;
}
```
```
#include <iostream>
int main()
{
	std::cout << doSomething(4, 3);
	return 0;
}
```
Если эти два параметра включены в одну и ту же программу, что и в примере, возникает конфликт имен, поскольку функция с тем же именем и параметром находится в той же области.
```
namespace Foo
{
	int doSomething(int x, int y)
	{
		return x + y;
	}
}
```
```
namespace Goo
{
	int doSomething(int x, int y)
	{
		return x - y;
	}
}
```
```
#include <iostream>

int main()
{
	std::cout << Foo::doSomething(4, 3); << '\n'
	std::cout << Goo::doSomething(4, 3); << endl
	return 0;
}
```
Если над проектом работают два разработчика и они оба решили назвать свою функцию doSomething, то при сборке будет больно. Поэтому можно использовать пространство имён. Для этого используем namespace Foo и namespace Goo. Таким образом обе функции doSomething не будут ничего знать друг о друге и всё скомпилируется успешно.
Оператор разрешения области действия (::) необходим для поиска идентификаторов в каждом пространстве имен.
Чтобы использовать этот оператор, добавьте к имени идентификатора префикс пространства имен, которое будет использоваться.
</details>
	
<details>
  <summary> CPP_01-ex00 </summary>
Два способа объявить зомби
Zombie stackZombie = Zombie("stackZombie");
Zombie *heapZombie = newZombie("heapZombie");
Области хранения данных: \
1. [text area] \
где хранится код программы, которую мы запускаем
2. [data] \
область где хранится global and static variables
3. [stack] \
Здесь сохраняются локальные переменные и параметры, связанные с вызовом функции.

Область стека выделяется вместе с вызовом функции и уничтожается по завершении вызова функции. Информация о вызове функции, хранящаяся в стеке, называется [кадром стека](https://en.wikipedia.org/wiki/Call_stack).

Область стека хранит данные методом push и извлекает данные методом pop. Поскольку этот стек работает в соответствии с методом «последним пришел — первым вышел», последние сохраненные данные извлекаются первыми.

Область стека распределяется от старшего адреса к младшему в памяти. Размер определяется во время выполнения
4. [heap] \
Это область памяти, которой пользователь может напрямую управлять и должен это делать. Пространство памяти динамически выделяется и освобождается пользователем.

Область кучи распределяется от младшего адреса к старшему адресу в памяти.

Размер определяется во время компиляции. Утечка памяти происходит, если выделение не освобождается в конце использования.
</details>
